; 使用 ca65 构建 SFC 程序ROM 的最小示例

.p816   ; 指示编译器是 65816(即 SFC 硬件使用的) 处理器
.i16    ; X/Y 寄存器设置为 16 位
.a8     ; A 寄存器设置为 8 位

.include "snes.inc"        ; 引入地址常量表
.include "charmap.inc"     ; 引入ASCII-128字符映射表

.segment "HEADER"    ; 设置头信息段
.byte "CA65 EXAMPLE" ; ROM 名称

.segment "ROMINFO"   ; 设置ROM信息段
.byte $30            ; ROM映射模式：LoROM, 支持快速访问
.byte 0              ; 不使用电池供电的RAM（即无游戏存档功能）
.byte $07            ; ROM 大小：128K
.byte 0,0,0,0        ; 保留字段
.word $AAAA,$5555    ; 虚拟的检验和其补码，在实际发布前，需要使用工具计算更新

.segment "CODE"      ; 从这里开始基本上全是代码段内容
   jmp start         ; 跳转到 start 标签处，即程序入口，用于兼容某些开发工具或模拟器，同时也符合 6502 时代早期的汇编风格

; 定义一些常量
VRAM_CHARSET   = $0000 ; 地址必须 $1000 (4K)边界对齐
VRAM_BG1       = $1000 ; 地址必须 $0400 (1K)边界对齐
VRAM_BG2       = $1400 ; 地址必须 $0400 (1K)边界对齐
VRAM_BG3       = $1800 ; 地址必须 $0400 (1K)边界对齐
VRAM_BG4       = $1C00 ; 地址必须 $0400 (1K)边界对齐
START_X        = 9
START_Y        = 14
START_TM_ADDR  = VRAM_BG1 + 32*START_Y + START_X

hello_str: .asciiz "Hello, World!"  ; 将字符串转为ASCII码序列，并添加NULL结尾(\0) 存储于此

; 程序入口地址标签,全局性标签
start:
   ; CLC(Clear Carry Flag) 清除进位标志位，即进入本地(native)模式
   ; 65816处理器在启动时默认为模拟(Emulation)模式，需要通过此指令切换到本地模式
   ; 模拟模式主要用于兼容旧 6502 处理器行为
   ; clc -> xce 从模拟模式切换到本地模式， sec -> xce 从本地模式切换到模拟模式
   clc
   xce
   ; rep (Reset Processor Status Bits) 重置处理器状态位
   ; X/Y 寄存器设置为 16 位
   rep #$10
   ; sep (Set Processor Status Bits) 设置处理器状态位
   ; A 寄存器设置为 8 位
   sep #$20

   ; 清空寄存器
   ; ldx (Load X Register) 从内存加载数据到 X 寄存器
   ; # 井号为立即数标识符，表示后面的数值为立即数（也就是数值字面量）
   ldx #$33

   ; 跳转到 ClearVRAM 函数，函数执行后，会接着执行下面的代码
   jsr ClearVRAM

; @ 为标签前缀，用于标识局部标签
; 局部标签是可以重复定义的，因为它只在定义的附近有效
; 局部标签只用于小范围内的代码块，比如循环体等
@loop:
   ; 很多指令的操作位数，都是看 P 寄存器的M状态位来决定的
   ; 比如 这里的 STZ 指令，就是根据 P 寄存器的M状态位来决定的复制的是1个字节还是2个字节

   ; STZ 支持格式：
   ; 绝对寻址：STZ $1234 (参数预期是16位的，结合DBR寄存器，所以是绝对寻址)
   ; 绝对索引寻址X：STZ $1234,X (第一参数预期16位数值)
   ; 绝对索引寻址Y：STZ $1234,Y (但是 65816 处理器不支持,所以 SFC 不支持)
   ; 直接页寻址：STZ $12,X (第一参数预期8位数据)

   ; INIDISP($2100) 是 PPU 控制寄存器起始地址
   ; stz (STore Zero) 将零存储到指定内存地址
   ; 即 $2100+$33 = $2133
   stz INIDISP,x
   ; NMITEMEN($4200) 是 NMI 控制寄存器，用于设置 NMI 中断的一些参数
   ; 即 $4200+$33 = $4233
   stz NMITIMEN,x
   ; 以下 DEX,BPL 指令结合实现了循环效果
   ; DEX(DEcrement X) X 寄存器减一
   ; 从而实现 $33-$00 ，STZ $2133, STZ $4233, -> STZ $2132, STZ $4232, -> STZ $2131, STZ $4231, ... -> STZ $2100, STZ $4200，将两个地址段的寄存器都清空
   ; $2100->$2133 是 PPU 控制寄存器，清空会重置所有显示设置
   ; $4200->$4233 是 NMI 控制寄存器，清空会禁用所有中断的DMA通道
   dex
   ; BPL(Branch on PLus) 如果 X 寄存器的值大于等于 0，则跳转到 @loop 标签处
   bpl @loop

   ; 重设显示设置
   ; 128 -> 0B10000000
   lda #128
   ; |                     0BIT: 强制消隐(Force Blanking)                   | 2-4BIT: 未使用 | 5-8BIT: 屏幕亮度 (0-15级) |
   ; | 0: 正常操作， 1:强制消隐（屏幕变黑，允许安全访问 VRAME、OAM、CGRAM） |                | 允许 16 级亮度调整        |
   sta INIDISP ; undo the accidental stz to 2100h due to BPL actually being a branch on nonnegative

   ; SFC 的颜色深度是 15 位，即 32768 种颜色，使用 16位宽数据存放
   ; 0B0_BBBBB_GGGGG_RRRRR
   ; 这里仍然要注意与 VRAM 相关的，高低位的顺序问题
   ; 目标是一个16位宽度15位颜色，第一次传输的是低位，第二次传输的是高位
   ; 以后面会出现的深红色为例，先后传输的是 $10 -> 0B00010000 和 $00 -> 0B00000000，也就是是说：
   ; 第一次传输的 0B00010000 存储在了 GGG_RRRRR
   ; 第二次传输的 0B00000000 存储在了 0B0_BBBBB_GGGG

   ; 顺便做一次颜色换算
   ; 这里对应下来就是 R=0B10000, G=0B00000, B=0B00000
   ; SFC 使用5位表示每个颜色通道，范围是 0-31
   ; 标准RGB使用8位表示每个颜色通道，范围是 0-255
   ; R6 / 255 = R5 / 31 => R6 = R5 * 255 / 31
   ; R5 = 0B10000 = 16, R6 = 16 * 255 / 31 = 131
   ; RGB(131, 0, 0) = #830000

   ; 设置一个黑色背景和三种不同深浅的红色
   ; CGADD($2121) 是 PPU 调色板地址寄存器，用于设置调色板的起始地址
   ; CGDATA($2122) 是 PPU 调色板数据寄存器，用于设置调色板的颜色
   ; CGADD($2121) 和 CGDATA($2122) 在这里配合使用， CGADD 设置了起始地址后，每次写入 CGDATA 后，写入地址就会自动+1
   ; 起始地址设置为 $0000
   stz CGADD

   ; $0000 -> 0B00000000_00000000 (黑色)
   stz CGDATA
   stz CGDATA

   ; $1000 -> 0B00010000_00000000 (深红)
   ; $10 -> 0B00010000
   ; 换算成 RGB 为 #800000
   lda #$10
   sta CGDATA
   stz CGDATA

   ; $1F00 -> 0B00011111_00000000 (中红)
   ; $1F -> 0B00011111
   lda #$1F
   sta CGDATA
   stz CGDATA
   
   ; $1F42 -> 0B00011111_01000010 (浅红) 
   ; $1F -> 0B00011111
   lda #$1F
   sta CGDATA
   ; $42 -> 0B01000010
   lda #$42
   sta CGDATA

   ; 这里也能看出调色板是连续的2字节数组
   ; SFC 中每个调色板占用 32个字节的 CGRAM
   ; Tiles 使用背景调色板(0-7)，Sprites 使用精灵调色板(8-15)
   ; 图块中的颜色索引是相对于调色板的索引，而不是直接的颜色值
   ; 实际颜色的地址公式：调色板索引 * 2 + 颜色索引*2


   ; 模式0 规格
   ; -------------------------------------------
   ; 背景层数：4(BG1-BG4)
   ; 瓦片大小：8x8(所有背景层使用 8x8 2bpp像素的瓦片)
   ; 色彩    ：每个层使用自己的 16色(4bit/pixel)调色板
   ; 分辨率  ：256x224(NTSC) 256x239(PAL)
   ; 地图规格：每个MAP可以有 32x32, 32x64, 64x32, 64x64 的瓦片（即四种分辨率）
   ; 内存使用：每个瓦片使用 16字节（8x8 像素，每个像素 2bit）
   ; 优先级  ：层之间可以设置优先级
   ; 特殊效果：支持背景层的水平和垂直滚动，可以对各层单独应用色彩数学效果
   ; 适用场景：文本与基本2D图形，常适用于RPG游戏的对话框、菜单等
   ; VRAM数据：VRAM中通常会存放：瓦片(Tile，也叫图块Charactor Data)、地图(Tile Map)、调色板(Palette)、精灵(Sprite Data)，特殊图形(MODE7)、背景图形(BG)、特效图形(Effect)等
   ; VRAM布局：各种数据需要自行规划，所以各图层都不是固定的
   ; 精灵    ：可以使用 8x8, 16x16 的瓦片


   ; BGMODE($2105) 是 PPU 显示模式寄存器，用于设置显示模式
   ; 设置为 模式0，即所有层都使用 8x8 的图块
   stz BGMODE
   ; # 表示立即数
   ; > 通常用于获取一个 16位或更大值的高字节
   ; < 获取低字节
   ; #>VRAM_BG1 也就是截取 VRAM_BG1($1000) 的高字节，即 $10
   lda #>VRAM_BG1
   ; BG1SC($2107) 是 PPU 显示区域设置寄存器，用于设置 BG1 显示区域
   ; 四个图层的设置寄存器地址是连续的：BG1SC($2107)、BG2SC($2108)、BG3SC($2109)、BG4SC($210A)
   ; | 1-6 BIT: 地图地址 | 7-8 BIT: 瓦片地图大小 |
   ; 瓦片地图大小：
   ;     0B00: 32x32 (4 路镜像)
   ;     0B01: 64x32 (2 路镜像)
   ;     0B10: 32x64 (2 路镜像)
   ;     0B11: 64x64
   sta BG1SC

   ; 这里就是把 高字节的高4位 拼成目标地址数据
   ; 这里相当于让 BG1和BG2 共用基地址
   lda #((>VRAM_CHARSET >> 4) | (>VRAM_CHARSET & $F0))
   ; BG12NBA($210B)，背景1和背景2的数据基址寄存器(以8K为单位)
   ; | 1-4 BIT: 背景1数据基址 | 5-8 BIT: 背景2数据基址 |
   ; VRAM 一共是 64K，也就是 8K * 8，所以这里设置的地址都是 8K 的倍数
   ; 0     -> 1     -> 2     -> 3     -> 4     -> 5     -> 6     -> 7
   ; $0000 -> $2000 -> $4000 -> $6000 -> $8000 -> $A000 -> $C000 -> $E000
   sta BG12NBA

   ; 以下开始将字符集写入 VRAM
   ; VRAM图形数据通常2个字节为单位
   ; VMAIN($2115) 设置VRAM 增量模式，设置后每次访问 VRAM 时，地址自动增量+1(具体地址+多少，看增量模式，比如模式1下就是+2，因为是字模式)
   ; 设置增量模式 $80，即“字”模式，每次访问 VRAM 时使用的了2个字节
   ;
   ; | 1 BIT: 地址增量使能 | 2-4 BIT: 未使用 | 5-6 BIT: 地址变换 | 7-8 BIT: 地址增量步长 |
   ;
   ; 地址增量使能: 0 禁用 1 启用
   ; 
   ; 地址变换
   ; %00 : 无变换
   ; %01 : 8位按位旋转
   ; %10 : 8位字节翻转
   ; %11 : 未使用
   ;
   ; 地址增量步长
   ; 
   ; %00 : 增量1(2字节)       -> 通常用于写入瓦片或者精灵数据
   ; %01 : 增量32(64字节)     -> 用于在 2bpp 模式下写入 32x32 瓦片地图
   ; %10 : 增量128(256字节)   -> 用于在 4bpp 模式下写入 32x32 瓦片地图
   ; %11 : 增量128(256字节)
   lda #$80
   sta VMAIN

   ; 读取预定义的 字符集 在 VRAM 中的16位地址
   ldx #VRAM_CHARSET
   ; STX 这类指令会自行处理 VRAM 的高低位问题，这里就是将 VRAM_CHARSET 的高低位分别写入了 VMADDL($2116) 和 VMADDH($2117)
   stx VMADDL

   ; 循环索引数归零
   ldx #0
@charset_loop:
   ; 程序开始时 X 设置为 8 bit模式，也就是每次只能取一个字节数据
   ; X 在循环前设置为 0， 也就是从 $(NESfont + 0) 开始
   lda NESfont,x
   ; VMDATAL($2118),VMDATAH($2119) 是VRAM的数据端口，这里要记住
   ; 就是目标地址的增量+1是什么时候触发的，这里是在 VMDATAH($2119) 写入后触发的，所以你可以实现只修改所有高位数值的操作
   ; 可以看到这里 1bpp 的写入与直觉不同
   ; 事实上向 VRAM 端口写入数据时，数据会做一次重排
   ; 比例这里， VMDATAL=0B00000000, VMDATAH=0B00001100
   ; 写入到 VRAM 时，会按照 高1位，低1位，高2位，低2位，... ... 高8位，低8位 的重排
   ; 重排结果为： 0B0000000010100000
   ; 也就是按 1bpp 的顺序扩充成了 2bpp，像素排列没变
   ; 每2位数据对应一个像素，同时对应调色板中的颜色索引，也就是 %10 -> 2，即调色板编号2的颜色，参考前面的调色板，为深红色
   stz VMDATAL
   sta VMDATAH
   ; X 索引+1，准备下一次循环
   inx
   ; 比较 X 值是否达到了 128*8=1024，也就是字符集的大小(8x8 1bpp 字符集，一个字符要传输读取8个字节，字符集里有128个ASCII字符)
   cpx #(128*8)
   ; 未到达条件，继续循环
   bne @charset_loop

   ; Place string tiles in background
   ldx #START_TM_ADDR
   stx VMADDL
   ldx #0
@string_loop:
   lda hello_str,x
   beq @enable_display
   sta VMDATAL
   lda #$20 ; priority 1
   sta VMDATAH
   inx
   bra @string_loop

@enable_display:
   ; Show BG1
   lda #$01
   sta TM
   ; Maximum screen brightness
   lda #$0F
   sta INIDISP

   ; enable NMI for Vertical Blank
   lda #$80
   sta NMITIMEN

   ; 程序的主循环，从这里开始，程序就一直循环执行
game_loop:
   ; wai (Wait for Interrupt) 指令会暂停程序执行，直到下一个中断发生
   ; 在 SFC 中，这通常是等待 V-Blank(垂直空白完成) 中断
   ; SFC 的显示是通过 PPU(图像处理单元)来实现的，PPU 会在每帧的最后一行发出一个中断信号，这个信号就是 V-Blank 中断
   ;
   ; 同步单位：
   ; SFC 的主要同步单位是帧，每秒 60 帧(准确地说是 60.098 Hz,SNES 则是 50帧)，所以 V-Blank 中断会发生 60 次/秒
   ;
   ; 帧率：
   ; 理想情况下，主流程的执行时间应该控制在 1帧之内，这样就不会出现卡顿的情况（对于NTSC，这意外着要在 16.67毫秒内完成）
   ;
   ; 时间控制目标：
   ; V-blank 是每帧结束时的一小段时间，大约占总帧时间的 10-20%,在这期间可以安全地更新 VRAM、OAM 和 CGRAM
   ; 
   ; 流程与时间分配：
   ; 游戏逻辑：应在活跃显示期间执行（非 V-blank 时间）
   ; 图形更新：应在 V-blank 期间执行
   ; 总帧时间：约 16.67 毫秒
   ; 游戏逻辑：约 13-14 毫秒
   ; V-blank 操作：约 2-3 毫秒
   ;
   ; 优化策略：
   ; 将耗时操作分散到多个帧中
   ; 使用中断和DMA来优化时间占用
   ; 文本渲染和更新应该在1帧时间内
   ; 复杂的文本效果可能需要跨多帧实现
   wai
   ; 这里开始写程序的主逻辑，比如游戏逻辑、输入处理、渲染等
   jmp game_loop


nmi:
   rep #$10        ; X/Y 16-bit
   sep #$20        ; A 8-bit
   phd
   pha
   phx
   phy
   ; Do stuff that needs to be done during V-Blank
   lda RDNMI ; reset NMI flag
   ply
   plx
   pla
   pld
return_int:
   rti

;----------------------------------------------------------------------------
; ClearVRAM -- 将 VRAM 清空（即：每个字节都设置为零）
; 代码来源： bazz 的 VRAM 教程
; 输入: 无
; 输出: 无
; 修改: 标志位
;----------------------------------------------------------------------------
ClearVRAM:
   ; 保存寄存器状态，只要保存这个函数里需要用到的寄存器就可以了
   ; 保存 A/X/P 寄存器，压入堆栈，以便后续恢复
   pha
   phx
   php

   ; REP,SEP 都是针对 P 寄存器的指令
   ; REP 会重置值为 1 的位对应的状态
   ; SEP 会设置值为 1 的位对应的状态
   ; P 寄存器的位定义如下：
   ;|    负数   |    溢出   |    内存/累加器标志位 |    索引寄存器宽度标志位 |    十进制模式标志位 |    中断屏蔽标志位   |   零标志位 | 进位标志位 |
   ;|     N    |     V    |           M        |           X          |         D        |          I        |     Z    |      C     |
   ;| Negative | Overflow | Memory/Accumulator | Index register size  |   Decimal mode   | Interrupt disable |    Zero  |    Carry   |
   ; 不是所有位组合码都有实际用途或频繁设置，比如 C,Z,V,N 通常是由算术和逻辑操作自动设置的
   ; REP(Reset Processor Status Bits) 重置处理器状态位，针对的是 P 寄存器
   ; $30 -> 0B00110000， 也就是重置 X/Y 寄存器为 16 位
   REP #$30		; mem/A = 8 bit, X/Y = 16 bit
   ; SEP(SET Processor Status Bits) 设置处理器状态位
   ; $20 -> 0B00100000， 也就是设置 A 寄存器为 8 位
   SEP #$20

   ; LDA(LoaD Accumulator) 从内存加载数据到 A 寄存器
   LDA #$80
   ; STA(STore Accumulator) 将 A 寄存器的值存储到指定内存地址
   ; $2100 - $21FF 主要用于 PPU(Picture Processing Unit，即图像处理单元) 寄存器
   ; $2115(VMAIN) 用于设置 VRAM 地址增量模式（也就是访问字节模式）
   ; 这里设置为字模式，即每次访问 VRAM 时，地址自动增加 2
   STA $2115

   ; SFC 使用 Little-Endian (小端)字节序，即低字节在前，高字节在后
   ; $1809 -> 0B00011000_000_01_0_0_1
   ; 0B0001_1000 -> $4300 高字节放于低地址
   ; 0B0000_1001 -> $4301 低字节放于高地址
   ; $4300 用于设置传输目标的偏移地址，DMA 的目标地址仅限于 $21xx 系列寄存器，所以这里8位地址是偏移量
   ; $4301 是 8位状态寄存器，用于设置 DMA 传输模式
   ;
   ; ### DMA 传输模式 ###
   ; 1-3bit: 未使用 | 4-5bit: 传输模式 | 6bit: HDMA间接寻址模式 | 7bit: 传输方向 | 8bit: 启用双寄存器I/O
   ;
   ; ### HDMA间接寻址模式 ###
   ; 允许在每个扫描线上自动更新寄存器，创建复杂图形效果，如每行变化的背景色或者模式7的透视效果
   ; 直接寻址模式HDMA表包含要传输的数据，间接寻址模式则包含指向实际数据的指针
   ; 直接模式适用于数据量较小或者变化不频繁的情况，间接模式适用于需要频繁更改大量数据的情况
   ; 间接模式允许更灵活地管理和更新 HDMA 数据，可以节省 WRAM，因为可以重用数据块
   ; HDMA 是一个复杂的功能，需要仔细规则时序
   ; 仅 HDMA 模式下有效，普通操作将忽略
   ;
   ; ### 传输模式 ### 
   ; A) 0B00(0): 1字节传输，同一地址
   ; 每次传输只写入/读取一个字节，目标是 $2100-$21FF 范围内的单个地址(由$4300指定)
   ; B) 0B01(1): 2字节传输，同一地址
   ; 每次传输写入/读取两个字节，同一地址(由$4300指定)，通常用于某些支持16位操作的寄存器
   ; C) 0B10(2): 2次1字节传输，连续地址
   ; 设$4300指定地址为 n，则 1st: $21n, 2nd: $21(n+1)，第二轮传输时 3rd: $21(n+2), 4th: $21(n+3) ... 以此类推
   ; D) 0B11(3): 2次2字节传输，交替地址
   ; 设$4300指定地址为 n，则 1st: $21n, 2nd: $21(n-1)，第二轮传输时 3rd: $21(n), 4th: $21(n-1) ... 以此类推
   ; 由于 VRAM 的 IO 仅限于 $2118,$2119，所以一般会设置为 $2119 实现交替
   ;
   ; ### 传输方向 ###
   ; 0: 从CPU到PPU,即写入 1: 从PPU到CPU，即读取
   ;
   ; ### 启用双寄存器I/O ###
   ; 0: 禁用 1: 启用对 VRAM 数据端口 ($2118,$2119) 的特殊处理
   ; --------------------------------------------------------
   ; VMRAM 是通过两个 8位 寄存器访问的，两者共同构成了一个 16位的 VRAM 数据端口
   ; $2119 负责高位数据， $2118 负责低位数据 (与SFC CPU的地址风格相反)
   ; 一般与 传输模式 0B11(交替地址模式) 一起使用(交替地址使用:n , n-1 的顺序读取和写入)
   LDX #$1809
   ; $4300 是 DMA 控制器0的参数寄存器地址，用于设置 DMA 传输模式
   ; 这是一个16位寄存器，低8位($4300)用于设置 DMA 模式，高8位($4301)用于设置传输模式等
   ; $2118,$2119 是 VRAM 数据I/O端口
   ; $2122 是 CGRAM 数据I/O端口
   ; $2124 是 OAM 数据I/O端口
   ; DMA 主要用途：快速向 VRAM 写入数据、更新调色板，修改精灵属性
   STX $4300

   ; 加载地址值0到X寄存器(16位模式)
   LDX #$0000
   ; $2116,$2117 是 VRAM 地址端口，用于设置 VRAM 相关操作的目标地址($2116低字节，$2117高字节)
   ; DMA 启动后会仅读取一次这个地址并保存，然后递增(不再需要这两个地址来读取)，直到传输完成
   ; 所以 DMA 启动期间，修改这个地址的值做别的任务不会有意外的影响
   STX $2116

   ; 一般来说写入不同的BANK，可以配合使用以下的指令
   ; PLB (Pull Bank Register) 从堆栈中弹出一个字节，存入BANK寄存器，可以事先将BANK寄存器的值压入堆栈，从而实现切换BANK
   ; LDA $XXYYZZ 使用长指令也可能从不同BANK读取数据
   ; MVP, MVN 指令也可以用于不同BANK之间的数据传输
   ; MVP 是从高地址向低地址移动
   ; MVN 是从低地址向高地址移动
   ; 格式：指令(MVP/MVN) 原BANK,目标BANK
   ; 寄存器用途：X 源地址，Y 目标地址，A 传输长度
   ; MVP/MVN 每执行一次 A 都自动减一
   ; A 寄存器最大可以设置为 16bit模式，即 0xFFFF，也就是可以复制 65536 个字节
   ; 复制操作或在 A 寄存器值为 0xFFFF 时结束(MVP/MVN 指令中，A 寄存器被视为无符号数， 0 - 1 = -1(无符号表示就是 0xFFFF))
   ; X/Y 自动-1(MVP)
   ; X/Y 自动+1(MVN)


   ; 向 $0000 地址写入 $0000，因为这是刚启动程序，所以其实就是写入到 $00:0000
   STX $0000

   ; $4302/$4303/$4304 是 DMA 控制器0的地址寄存器，用于设置 DMA 传输源起始地址
   ; $4302,$4303 用于设置源地址的低字节和高字节
   ; $4304 用于设置源地址的BANK号
   ; 这里设置源地址为 $00:0000，即程序的起始地址(也就是刚才初始为 0000 的那个地址)
   STX $4302
   LDA #$00
   STA $4304

   ; 传输的大小为 64K-1，也就是 65535 字节
   LDX #$FFFF
   ; $4305 是 DMA 控制器0的传输大小寄存器，用于设置 DMA 传输的大小
   ; $4305,$4306 用于设置传输大小的低字节和高字节
   ; DMA 的数据传输和 MVP/MVN 的计数逻辑相同，即每次传输后，传输大小会自动减一，直到计数器值为 $FFFF (即 0 - 1 = $FFFF)
   ; 这里设置传输大小为 64K-1，即 65535 字节
   ; 但实际上 DMA 是传输一个字节后计数器 -1，所以计数器为 0 的时候，传输还没有结束，DMA 再传输一个字节后，计数器会变为 $FFFF，才结束
   ; 所以最终传输的字节数为 65535($FFFF) + 1 = 65536 字节 = 64K
   STX $4305

   ; 非零值可以启动 DMA传输
   LDA #$01
   ; $420B 是 DMA 控制器0的启动寄存器，用于启动 DMA 传输
   STA $420B

   ; 等待 DMA 传输完成，然后用0填充最后一个字节
   ; 这是一个防御性技巧，为了避免 DMA 传输结束后，可能存在的数据残留(最后一个字节可能没有写入VRAM)
   ; $2119 是 VRAM 数据端口（高字节），也对应访问的VRAM最后一个字节(特别注意: VRAM 的高低字节顺序与SFC CPU的地址风格相反)
   ; 用0填充，相当于清空 VRAM 最后一个字节
   STZ $2119

   ; 按顺序将函数开头压入堆栈的寄存器状态恢复
   plp
   plx
   pla
   ; rts (Return from Subroutine) 从子程序返回，JSR 指令会跳转前的地址压入了堆栈，此指令会将其弹出并跳转到该地址
   RTS

.include "charset.asm"     ; 引入ASCII-128字符集
.include "ucs2char.asm"    ; 引入UCS-2字符集

.segment "VECTORS"
.word 0, 0        ;Native mode vectors
.word return_int  ;COP
.word return_int  ;BRK
.word return_int  ;ABORT
.word nmi         ;NMI
.word start       ;RST
.word return_int  ;IRQ

.word 0, 0        ;Emulation mode vectors
.word return_int  ;COP
.word 0
.word return_int  ;ABORT
.word nmi         ;NMI
.word start       ;RST
.word return_int  ;IRQ